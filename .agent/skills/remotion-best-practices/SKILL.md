---
name: remotion-best-practices
description: Best practices for Remotion - Video creation in React
metadata:
  tags: remotion, video, react, animation, composition, ai, captions
---

# Remotion AI Video Editing Skills

This document contains the consolidated best practices and rules for using Remotion to generate programmatic AI video animations, compiled directly from open-source paradigms to give agents native animation capabilities.

## 1. Core Animations & Timing
- **Strict Requirement:** All animations MUST be driven by the `useCurrentFrame()` hook.
- **Timing:** Calculate timings in seconds and multiply by the `fps` value provided by `useVideoConfig()`.
- **FORBIDDEN:** CSS transitions, CSS `@keyframes`, and Tailwind animation classes are strictly forbidden because they cannot be synchronized with Remotion's frame-by-frame rendering and will fail to render correctly in exports.
- **Interpolation:** Use `interpolate(frame, [startFrame, endFrame], [startValue, endValue], { extrapolateRight: 'clamp' })` to smoothly animate style properties.

## 2. Compositions & Metadata
- **Definition:** Define renderable videos using the `<Composition>` component in the root file. Specify `durationInFrames`, `fps`, `width`, and `height`.
- **Default Props:** Pass `defaultProps` using JSON-serializable types.
- **Calculate Metadata:** Use the `calculateMetadata` prop to asynchronously fetch data, determine video durations dynamically before rendering, or transform props. The function can return `durationInFrames`, `width`, `height`, and an overridden `props` object.

## 3. Sequencing & Series
- **Delaying Elements:** Use `<Sequence from={startFrame} durationInFrames={length} premountFor={1 * fps}>` to delay when an element appears.
- **Premounting:** *ALWAYS* use `premountFor` on sequences to ensure heavy assets or fonts are loaded before they become visible.
- **Sequential Playback:** Use `<Series>` and `<Series.Sequence>` to play elements back-to-back automatically. Use the `offset` prop for overlapping items (e.g., transitions).
- **Local Frames:** Remember that `useCurrentFrame()` inside a `<Sequence>` returns the *local* frame (starting from 0 for that sequence), not the absolute composition frame.

## 4. Captions & Subtitles
- **Parsing SRT:** Use `parseSrt({ input: text })` from `@remotion/captions` to ingest external subtitle files generated by AI transcription systems (like Whisper).
- **TikTok-Style Pages:** Group words dynamically into pages using `createTikTokStyleCaptions({ captions, combineTokensWithinMilliseconds: 1200 })`. Map over these pages and render each inside a `<Sequence>`.
- **Active Word Highlighting:** Calculate the absolute time: `const absoluteTimeMs = page.startMs + ((frame / fps) * 1000)`. Highlight words where `token.fromMs <= absoluteTimeMs && token.toMs > absoluteTimeMs`.

## 5. Text Animations
- **Typewriter Effects:** Implement typewriter logic via strictly character-by-character string slicing calculated from `useCurrentFrame()`. Never use per-character opacity manipulation for typewriters.
- **Highlighter Effects:** Implement highlighter pen style animations by rendering a solid colored bounding box behind the active text segment that expands its width via `interpolate(...)` based on the frame.
